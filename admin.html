<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Palace Cars - Panneau d'Administration</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Poppins:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- Icônes Font Awesome: CORRECTION de xintegrity en integrity -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" xintegrity="sha512-SnH5WK+bZxgPHs44uWIX+LLMDJd4qFf3F5f5qK2K6Q24L+nkA5bf5F3Gmf0iVCi/2fA/wz2N9H/Gz9oW9sP7Cg==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <link rel="manifest" href="/manifest.json">
    <style>
        body { font-family: 'Poppins', sans-serif; background-color: #f1f5f9; } /* Slate-100 */
        :root {
            --color-primary: #2563eb; /* Blue-600 */
            --color-accent: #f59e0b; /* Amber-500 */
            --color-text-dark: #1e293b; /* Slate-800 */
        }
        .btn { padding: 0.5rem 1rem; border-radius: 0.5rem; /* rounded-lg */ font-weight: 600; transition: all 0.3s ease; text-align: center; display: inline-flex; align-items: center; justify-content: center; }
        .btn-primary { background-color: var(--color-primary); color: white; }
        .btn-primary:hover:not(:disabled) { background-color: #1d4ed8; /* Blue-700 */ }
        .btn-danger { background-color: #dc2626; /* Red-600 */ color: white; }
        .btn-danger:hover:not(:disabled) { background-color: #b91c1c; /* Red-700 */ }
        .btn-success { background-color: #16a34a; /* Green-600 */ color: white; }
        .btn-success:hover:not(:disabled) { background-color: #15803d; /* Green-700 */ }
        .btn-secondary { background-color: #64748b; /* Slate-500 */ color: white; }
        .btn-secondary:hover:not(:disabled) { background-color: #475569; /* Slate-600 */ }
        .btn-warning { background-color: var(--color-accent); color: var(--color-text-dark); }
        .btn-warning:hover:not(:disabled) { background-color: #d97706; /* Amber-600 */ }
        .btn-sm { padding: 0.25rem 0.75rem; font-size: 0.875rem; }
        .btn:disabled { opacity: 0.5; cursor: not-allowed; }

        .tab-button { padding: 0.75rem 1.5rem; font-weight: 600; color: #475569; /* Slate-600 */ border-bottom: 3px solid transparent; transition: all 0.3s ease; }
        .tab-button.active { color: var(--color-primary); border-color: var(--color-primary); }
        .tab-button:hover:not(.active) { color: var(--color-text-dark); }

        /* Styles pour la modale */
        #confirmation-modal {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            transition: opacity 0.3s ease-in-out;
        }
        .modal-content {
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            max-width: 500px;
        }
        /* Animation d'apparition de la modale */
        #confirmation-modal:not(.hidden) { opacity: 1; }
        #confirmation-modal:not(.hidden) .modal-content {
            opacity: 1; transform: translateY(0) scale(1);
        }

        /* Login Form */
        #login-overlay { background-color: rgba(241, 245, 249, 0.9); backdrop-filter: blur(10px); -webkit-backdrop-filter: blur(10px); }

        /* NOUVEAU: Modale de confirmation custom */
        #custom-confirm-modal {
            background-color: rgba(0, 0, 0, 0.6);
            backdrop-filter: blur(5px); -webkit-backdrop-filter: blur(5px);
            transition: opacity 0.3s ease-in-out;
            z-index: 60; /* Au-dessus de la modale de réservation */
        }
        #custom-confirm-modal:not(.hidden) { opacity: 1; }
        #custom-confirm-modal:not(.hidden) .modal-content {
             opacity: 1; transform: translateY(0) scale(1);
        }
    </style>
</head>
<body class="min-h-screen bg-gray-100">

    <!-- Authentification Overlay -->
    <div id="login-overlay" class="fixed inset-0 z-50 flex items-center justify-center p-4">
        <div class="bg-white p-8 rounded-2xl shadow-2xl w-full max-w-sm text-center border border-gray-200">
            <h2 class="text-3xl font-bold text-primary">Accès Admin</h2>
            <p class="text-gray-600 mb-6">Veuillez entrer le mot de passe pour accéder au panneau.</p>
            <input type="password" id="password-input" class="w-full px-4 py-3 border border-gray-300 rounded-lg text-center text-lg shadow-inner focus:outline-none focus:ring-2 focus:ring-primary" placeholder="Entrez le mot de passe">
            <button id="login-button" class="btn btn-primary w-full mt-6 py-3 text-lg">
                <i class="fas fa-sign-in-alt mr-2"></i> Connexion
            </button>
            <p id="login-error" class="text-red-500 mt-4 text-sm font-medium hidden">Mot de passe incorrect.</p>
        </div>
    </div>

    <!-- Contenu Principal (Caché par défaut) -->
    <div id="main-content" class="hidden opacity-0 transition-opacity duration-500">

        <!-- Header -->
        <header class="bg-white shadow-md sticky top-0 z-40">
            <div class="container mx-auto px-4 sm:px-6 lg:px-8">
                <div class="flex justify-between items-center h-20">
                    <!-- Logo/Titre -->
                    <div class="flex-shrink-0 flex items-center">
                        <i class="fas fa-car-on text-primary text-3xl"></i>
                        <h1 class="text-2xl font-bold text-text-dark ml-3">Palace Cars <span class="font-normal text-gray-500">Admin</span></h1>
                    </div>
                    <!-- Notifications -->
                    <div>
                        <button id="enable-notifications" class="btn btn-secondary btn-sm">
                            <i class="fas fa-bell mr-2"></i> Activer les Notifications
                        </button>
                        <span id="notifications-status" class="text-sm text-green-600 font-medium ml-3 hidden">
                            <i class="fas fa-check-circle"></i> Alertes activées.
                        </span>
                    </div>
                </div>
            </div>
        </header>

        <!-- Contenu Page -->
        <main class="container mx-auto p-4 sm:p-6 lg:p-8">

            <!-- Message Box Global -->
            <div id="admin-message-box" class="hidden p-4 rounded-lg text-center mb-6 font-medium"></div>

            <div class="flex flex-col lg:flex-row lg:space-x-8">

                <!-- Colonne Principale: Réservations -->
                <div class="lg:w-2/3 w-full">
                    <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-200">
                        <h2 class="text-2xl font-bold text-text-dark mb-5">Boîte de Réception des Réservations</h2>

                        <!-- Tabs -->
                        <div class="border-b border-gray-200 mb-5">
                            <nav class="flex space-x-4">
                                <button id="tab-new" class="tab-button active">
                                    Nouvelles Demandes (<span id="count-new">0</span>)
                                </button>
                                <button id="tab-confirmed" class="tab-button">
                                    Réservations Confirmées (<span id="count-confirmed">0</span>)
                                </button>
                            </nav>
                        </div>

                        <!-- Liste des Réservations -->
                        <div id="bookings-list" class="space-y-5">
                            <!-- Les réservations seront injectées ici -->
                            <p id="loading-bookings" class="text-center text-gray-500 py-10">Chargement des réservations...</p>
                        </div>
                    </div>
                </div>

                <!-- Colonne Latérale: Gestion Disponibilité -->
                <div class="lg:w-1/3 w-full mt-8 lg:mt-0 lg:sticky lg:top-28" style="align-self: flex-start;">
                    <!-- Gérer Disponibilité -->
                    <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-200 mb-8">
                        <h3 class="text-xl font-bold text-text-dark mb-5">Ajouter Période Indisponible</h3>
                        <form id="unavailability-form" class="space-y-4">
                            <div>
                                <label for="unav-car" class="block text-sm font-semibold text-gray-700 mb-1">Voiture</label>
                                <select id="unav-car" name="car" required class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                                    <option value="" disabled selected>Choisir...</option>
                                    <!-- Options remplies par JS -->
                                </select>
                            </div>
                            <!-- Date et Heure de Début -->
                            <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Début Indisponibilité</label>
                                <div class="flex gap-2">
                                    <input type="date" id="unav-start-date" name="startDate" required class="w-1/2 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                                    <input type="time" id="unav-start-time" name="startTime" required class="w-1/2 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                                </div>
                            </div>
                             <!-- Date et Heure de Fin -->
                             <div>
                                <label class="block text-sm font-semibold text-gray-700 mb-1">Fin Indisponibilité</label>
                                <div class="flex gap-2">
                                    <input type="date" id="unav-end-date" name="endDate" required class="w-1/2 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                                    <input type="time" id="unav-end-time" name="endTime" required class="w-1/2 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                                </div>
                            </div>
                            <button type="submit" id="add-period-button" class="btn btn-primary w-full py-2.5">
                                <i class="fas fa-plus-circle mr-2"></i> Ajouter Période
                            </button>
                        </form>
                    </div>

                    <!-- Statut Manuel -->
                    <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-200 mb-8">
                         <h3 class="text-xl font-bold text-text-dark mb-5">Statut Actuel des Voitures</h3>
                         <div id="manual-status-list" class="space-y-3">
                             <!-- Statuts chargés par JS -->
                         </div>
                    </div>

                      <!-- Périodes Programmées -->
                    <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-200 mb-8">
                         <h3 class="text-xl font-bold text-text-dark mb-5">Périodes Programmées</h3>
                         <div id="periods-list" class="space-y-3 max-h-60 overflow-y-auto pr-2">
                             <!-- Périodes chargées par JS -->
                             <p id="loading-periods" class="text-center text-gray-500 py-4">Chargement...</p>
                         </div>
                    </div>

                    <!-- NOUVELLE SECTION: Clients Fidèles -->
                    <div class="bg-white p-6 rounded-2xl shadow-lg border border-gray-200">
                        <h3 class="text-xl font-bold text-text-dark mb-5">Historique des Clients</h3>
                        <div class="flex justify-between items-center mb-3 border-b pb-2 text-sm font-semibold text-gray-500">
                            <span>Client</span>
                            <span>Réservations</span>
                        </div>
                        <div id="client-history-list" class="space-y-3 max-h-60 overflow-y-auto pr-2">
                            <p id="loading-client-history" class="text-center text-gray-500 py-4">Chargement...</p>
                            <!-- Les clients fidèles seront injectés ici -->
                        </div>
                    </div>

                </div>
            </div>
        </main>
    </div>

    <!-- Modale de Confirmation -->
    <div id="confirmation-modal" class="fixed inset-0 z-50 flex items-center justify-center p-4 hidden opacity-0">
        <div class="modal-content bg-white p-6 md:p-8 rounded-2xl shadow-2xl w-full max-w-lg opacity-0 transform scale-95 -translate-y-10 border border-gray-200">
            <div class="flex justify-between items-center mb-5">
                <h2 class="text-2xl font-bold text-primary">Confirmer la Réservation</h2>
                <button id="close-modal-button" class="text-gray-400 hover:text-gray-700 text-2xl transition-colors">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            <p class="text-gray-600 mb-6">Veuillez vérifier ou modifier les dates/heures si nécessaire avant de confirmer. La confirmation bloquera la voiture pour cette période.</p>
            
            <div id="modal-booking-details" class="text-gray-700 mb-6 p-4 bg-blue-50 rounded-lg border border-blue-200">
                <!-- Détails de la réservation chargés ici -->
            </div>

            <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
                  <!-- Date et Heure de Début -->
                <div>
                    <label for="modal-start-date" class="block text-sm font-semibold text-gray-700 mb-1">Début Location</label>
                    <input type="date" id="modal-start-date" name="modalStartDate" required class="block w-full mb-2 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                    <input type="time" id="modal-start-time" name="modalStartTime" required class="block w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                </div>
                <!-- Date et Heure de Fin -->
                <div>
                    <label for="modal-end-date" class="block text-sm font-semibold text-gray-700 mb-1">Fin Location</label>
                    <input type="date" id="modal-end-date" name="modalEndDate" required class="block w-full mb-2 px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                    <input type="time" id="modal-end-time" name="modalEndTime" required class="block w-full px-3 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary">
                </div>
            </div>

            <p id="modal-error" class="text-red-500 mt-4 text-sm font-medium text-center hidden">Erreur : La date de fin doit être après la date de début.</p>

            <div class="mt-8 flex justify-end space-x-3">
                 <button id="cancel-modal-button" class="btn btn-secondary">Annuler</button>
                 <button id="confirm-modal-button" class="btn btn-success" disabled>
                     <i class="fas fa-check mr-2"></i> Confirmer la Réservation
                 </button>
            </div>
        </div>
    </div>

    <!-- NOUVELLE Modale de Confirmation Custom (pour alert/confirm) -->
    <div id="custom-confirm-modal" class="fixed inset-0 z-[60] flex items-center justify-center p-4 hidden opacity-0">
        <div class="modal-content bg-white p-6 md:p-8 rounded-2xl shadow-2xl w-full max-w-md opacity-0 transform scale-95 -translate-y-10 border border-gray-200">
            <h2 id="custom-confirm-title" class="text-2xl font-bold text-text-dark mb-4">Confirmation</h2>
            <p id="custom-confirm-message" class="text-gray-600 mb-8">Êtes-vous sûr ?</p>
            <div class="flex justify-end space-x-3">
                 <button id="custom-confirm-cancel" class="btn btn-secondary">Annuler</button>
                 <button id="custom-confirm-ok" class="btn btn-danger">Confirmer</button>
            </div>
        </div>
    </div>


    <!-- Imports Firebase -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getFirestore, collection, addDoc, onSnapshot, query, 
            where, orderBy, doc, getDoc, getDocs, updateDoc, deleteDoc, 
            Timestamp, serverTimestamp, setDoc, writeBatch 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // *** Configuration Firebase ***
        // (L'utilisateur doit coller sa configuration ici)
        const firebaseConfig = {
          apiKey: "AIzaSyCsPHf_v8-gEiWGQzkwses-jOiDXs9tvWo",
          authDomain: "palace-cars.firebaseapp.com",
          projectId: "palace-cars",
          storageBucket: "palace-cars.firebasestorage.app",
          messagingSenderId: "469852272715",
          appId: "1:469852272715:web:6e87dc7083cdc04e03b5ce",
          measurementId: "G-KCEF4WBW0G"
        };
        // *** Fin Configuration Firebase ***


        // --- Variables Globales ---
        let db;
        let bookingsCollectionRef;
        let unavailabilityPeriodsCollectionRef;
        let carManualStatusCollectionRef;
        let dbReady = false;
        let allBookingsCache = []; // Cache pour stocker toutes les réservations
        let currentView = 'new'; // 'new' or 'confirmed'
        let currentBookingId = null; // Pour la modale de confirmation
        let currentBookingData = null; // Pour la modale de confirmation
        let isConfirmationBusy = false; // Verrou pour éviter double-clic
        let isFirstLoad = true; // NOUVEAU: Pour la gestion des notifications

        // Liste statique des voitures
        const carOptions = [
            "Dacia Logan Diesel 2024",
            "Dacia Logan Diesel 2025",
            "Dacia Sandero Essence",
            "Dacia Sandero Diesel",
            "Renault Clio 5 Diesel"
        ];
        
        // --- NOUVEAU: Map des éléments DOM ---
        // (Pour éviter les erreurs "Éléments UI manquants")
        const domElements = {};
        
        // --- NOUVEAU: Logique de Confirmation Custom ---
        let confirmResolve = null;
        function customConfirm(message, title = "Confirmation", okClass = 'btn-danger') {
            const modal = domElements.customConfirmModal;
            const titleEl = domElements.customConfirmTitle;
            const messageEl = domElements.customConfirmMessage;
            const okButton = domElements.customConfirmOk;
            const cancelButton = domElements.customConfirmCancel;

            titleEl.textContent = title;
            messageEl.innerHTML = message.replace(/\n/g, '<br>'); // Supporte les sauts de ligne
            
            // Appliquer le style au bouton OK (par ex. btn-danger pour suppression)
            okButton.className = `btn ${okClass}`;

            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
            setTimeout(() => modal.querySelector('.modal-content').classList.remove('opacity-0', 'scale-95', '-translate-y-10'), 50);

            return new Promise((resolve) => {
                confirmResolve = resolve;
            });
        }
        
        function setupCustomConfirmListeners() {
            domElements.customConfirmOk.addEventListener('click', () => {
                if (confirmResolve) confirmResolve(true);
                closeCustomConfirm();
            });
            domElements.customConfirmCancel.addEventListener('click', () => {
                if (confirmResolve) confirmResolve(false);
                closeCustomConfirm();
            });
        }
        
        function closeCustomConfirm() {
            const modal = domElements.customConfirmModal;
            modal.querySelector('.modal-content').classList.add('opacity-0', 'scale-95', '-translate-y-10');
            setTimeout(() => {
                modal.classList.add('opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                    confirmResolve = null;
                }, 300);
            }, 300);
        }


        // --- FONCTIONS UTILITAIRES ---

        function formatReadableDateTime(timestamp) {
            if (!timestamp || !timestamp.seconds) {
                // Essayer de le traiter comme une date-chaîne (ex: 2025-10-24 10:30)
                if(typeof timestamp === 'string') {
                    // Si c'est juste une date (YYYY-MM-DD) et une heure (HH:MM)
                    const parts = timestamp.split(' ');
                    if(parts.length === 2) {
                        const dateParts = parts[0].split('-');
                        const timeParts = parts[1].split(':');
                        if (dateParts.length === 3 && timeParts.length >= 2) {
                             // Utiliser le fuseau horaire du Maroc (WET = UTC+0/UTC+1, utilisons 'Africa/Casablanca' pour être sûr)
                             // Note: Ceci est pour l'affichage. L'entrée est supposée être locale.
                            try {
                                const date = new Date(parseInt(dateParts[0]), parseInt(dateParts[1])-1, parseInt(dateParts[2]), parseInt(timeParts[0]), parseInt(timeParts[1]));
                                if(!isNaN(date)) {
                                    return new Intl.DateTimeFormat('fr-FR', {
                                        day: '2-digit', month: '2-digit', year: 'numeric',
                                        hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Africa/Casablanca'
                                    }).format(date).replace('à ', '');
                                }
                            } catch (e) { console.error("Erreur formatage date string:", e); }
                        }
                    }
                }
                return "Date non spécifiée"; // Retour par défaut
            }
            // Si c'est un objet Timestamp Firebase
            const date = new Date(timestamp.seconds * 1000 + (timestamp.nanoseconds || 0) / 1000000);
            return new Intl.DateTimeFormat('fr-FR', {
                day: '2-digit', month: '2-digit', year: 'numeric',
                hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Africa/Casablanca' // Utiliser UTC+1
            }).format(date).replace('à ', '');
        }

        // Convertit un Timestamp Firebase en { date: 'YYYY-MM-DD', time: 'HH:MM' } (pour les inputs de la modale)
        // ** NOUVELLE LOGIQUE: Utilise le fuseau horaire 'Africa/Casablanca' pour l'affichage **
        function getDateTimeObjectFromTimestamp(timestamp) {
            if (!timestamp || !timestamp.seconds) return { date: '', time: '12:00' }; // Défaut 12:00 si non trouvé
            try {
                const date = new Date(timestamp.seconds * 1000 + (timestamp.nanoseconds || 0) / 1000000);
                
                // Formater la date en utilisant IANA 'Africa/Casablanca'
                const optionsDate = { year: 'numeric', month: '2-digit', day: '2-digit', timeZone: 'Africa/Casablanca' };
                const optionsTime = { hour: '2-digit', minute: '2-digit', hour12: false, timeZone: 'Africa/Casablanca' };

                const dateParts = new Intl.DateTimeFormat('fr-FR', optionsDate).format(date).split('/');
                // Gérer le formatage fr-FR (DD/MM/YYYY)
                if (dateParts.length === 3) {
                    const dateISO = `${dateParts[2]}-${dateParts[1]}-${dateParts[0]}`; // Re-construire en YYYY-MM-DD
                    
                    const timeStr = new Intl.DateTimeFormat('fr-FR', optionsTime).format(date);
                    
                    // Gérer le cas '24:00' qui peut arriver
                    const timeISO = timeStr.replace('24:', '00:');
                    
                    if (dateISO !== 'Invalid Date' && timeISO) {
                        return { date: dateISO, time: timeISO };
                    }
                }
                throw new Error("Format de date Intl inattendu");

            } catch (e) {
                console.error("Erreur conversion timestamp en ISO local:", e, timestamp);
                // Fallback (peut être décalé si le serveur n'est pas au Maroc)
                const d = new Date(timestamp.seconds * 1000);
                d.setMinutes(d.getMinutes() + d.getTimezoneOffset()); // Tenter de compenser l'UTC
                
                // Si le timestamp est valide, on essaie un fallback
                if (!isNaN(d.getTime())) {
                    const year = d.getFullYear();
                    const month = String(d.getMonth() + 1).padStart(2, '0');
                    const day = String(d.getDate()).padStart(2, '0');
                    const hour = String(d.getHours()).padStart(2, '0');
                    const minute = String(d.getMinutes()).padStart(2, '0');
                    return { date: `${year}-${month}-${day}`, time: `${hour}:${minute}` };
                }
                return { date: '', time: '12:00' }; // Fallback final
            }
        }


        // Fonction utilitaire pour convertir YYYY-MM-DD et HH:MM (depuis le formulaire) en objet Date (en UTC)
        // ** CORRECTION FUSEAU HORAIRE **
        function getDateTimeObjectFromISO(dateStr, timeStr) {
             try {
                 if (!dateStr || !timeStr) throw new Error("Date ou heure manquante");
                 const [year, month, day] = dateStr.split('-');
                 const [hour, minute] = timeStr.split(':');
                 // Interprète la date comme étant locale au Maroc (Africa/Casablanca)
                 // Puis crée un objet Date.
                 // Note: C'est complexe. Le plus simple est de créer un objet Date en local (navigateur)
                 // Le Timestamp.fromDate() le convertira en UTC.
                 const d = new Date(parseInt(year), parseInt(month) - 1, parseInt(day), parseInt(hour), parseInt(minute), 0);
                 
                 if (isNaN(d.getTime())) { throw new Error("Date invalide"); }
                 return d;
             } catch (e) {
                 console.error("Erreur conversion ISO date/heure:", dateStr, timeStr, e);
                 return null;
             }
        }

        function showAdminMessage(message, type = 'info', duration = 5000) {
            const msgBox = domElements.adminMessageBox;
            if (!msgBox) return;

            msgBox.textContent = message;
            msgBox.className = 'p-4 rounded-lg text-center mb-6 font-medium border text-sm'; // Reset
            msgBox.classList.remove('bg-green-100', 'border-green-300', 'text-green-800', 'bg-red-100', 'border-red-300', 'text-red-800', 'bg-yellow-100', 'border-yellow-300', 'text-yellow-800');

            if (type === 'success') {
                msgBox.classList.add('bg-green-100', 'border-green-300', 'text-green-800');
            } else if (type === 'error') {
                msgBox.classList.add('bg-red-100', 'border-red-300', 'text-red-800');
            } else if (type === 'warning') {
                msgBox.classList.add('bg-yellow-100', 'border-yellow-300', 'text-yellow-800');
            }
            msgBox.classList.remove('hidden');
            
            setTimeout(() => {
                msgBox.classList.add('hidden');
            }, duration);
        }

        function populateCarSelects() {
            const unavCarSelect = domElements.unavCar; // CORRECTION: "unavCarSelect" remplacé par "unavCar"
            if (!unavCarSelect) return;
            const placeholder = unavCarSelect.querySelector('option[disabled]');
            unavCarSelect.innerHTML = '';
            if (placeholder) unavCarSelect.appendChild(placeholder);
            carOptions.forEach(car => {
                unavCarSelect.options.add(new Option(car, car));
            });
        }


        // --- FONCTIONS D'AFFICHAGE (Rendering) ---

        function createBookingCard(booking) {
            const card = document.createElement('div');
            card.className = 'border border-gray-200 rounded-xl shadow-sm overflow-hidden';
            card.id = `booking-${booking.id}`;

            // Assurer que le timestamp est valide avant de formater
            const receivedAt = booking.timestamp ? formatReadableDateTime(booking.timestamp) : 'Date inconnue';
            
            // Créer les chaînes de date/heure pour l'affichage (depuis les champs string ou timestamps)
            let pickupDateTime = `${booking.datePriseEnCharge || 'jj/mm/aaaa'} ${booking.heurePriseEnCharge || 'hh:mm'}`;
            let returnDateTime = `${booking.dateRetour || 'jj/mm/aaaa'} ${booking.heureRetour || 'hh:mm'}`;
            
            // Si les timestamps existent (préféré car plus précis), les utiliser
            if (booking.pickupTimestamp) {
                pickupDateTime = formatReadableDateTime(booking.pickupTimestamp);
            }
            if (booking.returnTimestamp) {
                returnDateTime = formatReadableDateTime(booking.returnTimestamp);
            }

            const statusClass = booking.confirmed ? 'bg-green-100 text-green-700' : 'bg-blue-100 text-blue-700';
            const statusText = booking.confirmed ? '<i class="fas fa-check-circle mr-1.5"></i> Confirmée' : '<i class="fas fa-hourglass-start mr-1.5"></i> Nouvelle Demande';

            card.innerHTML = `
                <div class="p-5">
                    <div class="flex justify-between items-start mb-4">
                        <div>
                            <span class="text-xs text-gray-500 font-medium">Reçu le : ${receivedAt}</span>
                            <span class="ml-3 px-2.5 py-0.5 rounded-full text-xs font-semibold ${statusClass}">${statusText}</span>
                        </div>
                    </div>
                    <h3 class="text-xl font-bold text-text-dark mb-1">${booking.nomPrenom || 'Nom non spécifié'}</h3>
                    <p class="text-sm text-gray-600 mb-4 break-words">
                        <a href="tel:${booking.telephone}" class="text-primary hover:underline">${booking.telephone || 'Téléphone non spécifié'}</a> | 
                        <a href="mailto:${booking.email}" class="text-primary hover:underline">${booking.email || 'Email non spécifié'}</a>
                    </p>
                    
                    <div class="border-t border-gray-100 pt-4">
                        <h4 class="text-md font-semibold text-text-dark mb-3">Voiture : <span class="font-bold text-lg text-primary">${booking.voiture || 'Non spécifiée'}</span></h4>
                        <div class="grid grid-cols-2 gap-x-4 gap-y-2 text-sm">
                            <div class="text-gray-700"><i class="fas fa-calendar-alt w-5 text-gray-400 mr-1"></i> <strong class="font-medium">Prise en charge:</strong></div>
                            <div class="font-semibold text-gray-800">${pickupDateTime}</div>
                            <div class="text-gray-700"><i class="fas fa-map-marker-alt w-5 text-gray-400 mr-1"></i> <strong class="font-medium">Lieu:</strong></div>
                            <div class="text-gray-800 break-words">${booking.lieuPriseEnCharge || 'Non spécifié'}</div>
                            
                            <div class="text-gray-700"><i class="fas fa-calendar-check w-5 text-gray-400 mr-1"></i> <strong class="font-medium">Retour:</strong></div>
                            <div class="font-semibold text-gray-800">${returnDateTime}</div>
                            <div class="text-gray-700"><i class="fas fa-map-marker-alt w-5 text-gray-400 mr-1"></i> <strong class="font-medium">Lieu:</strong></div>
                            <div class="text-gray-800 break-words">${booking.lieuRetour || 'Non spécifié'}</div>
                        </div>
                    </div>
                </div>
                <div class="bg-gray-50 px-5 py-4 flex justify-end space-x-3">
                    <button class="btn btn-success btn-sm confirm-button ${booking.confirmed ? 'hidden' : ''}" data-id="${booking.id}">
                        <i class="fas fa-check mr-1.5"></i> Confirmer
                    </button>
                    <button class="btn btn-danger btn-sm delete-button" data-id="${booking.id}">
                        <i class="fas fa-trash-alt mr-1.5"></i> Supprimer
                    </button>
                    <a href="https://wa.me/${(booking.telephone || '').replace(/\D/g, '')}?text=Bonjour%20${encodeURIComponent(booking.nomPrenom || '')},%20concernant%20votre%20demande%20de%20r%C3%A9servation%20pour%20la%20${encodeURIComponent(booking.voiture || '')}%20du%20${encodeURIComponent(pickupDateTime)}%20au%20${encodeURIComponent(returnDateTime)}..." target="_blank" class="btn btn-secondary btn-sm !bg-green-500 hover:!bg-green-600">
                        <i class="fab fa-whatsapp mr-1.5"></i> Contacter
                    </a>
                </div>
            `;

            // Attacher les écouteurs d'événements
            card.querySelector('.confirm-button')?.addEventListener('click', () => openConfirmationModal(booking.id));
            card.querySelector('.delete-button')?.addEventListener('click', () => handleDeleteBooking(booking.id));

            return card;
        }

        function createPeriodListItem(period) {
            const item = document.createElement('div');
            item.className = 'bg-blue-50 border border-blue-200 rounded-lg p-3 text-sm flex justify-between items-center';
            item.id = `period-${period.id}`;

            const carName = period.car || "Inconnue";
            const startDate = period.startDate ? formatReadableDateTime(period.startDate) : "N/A";
            const endDate = period.endDate ? formatReadableDateTime(period.endDate) : "N/A";
            const typeText = period.type === 'booking' ? '(Réservé)' : '(Manuel)';

            item.innerHTML = `
                <div>
                    <strong class="text-primary">${carName}</strong> ${typeText}
                    <p class="text-xs text-gray-600">${startDate} - ${endDate}</p>
                </div>
                <button data-id="${period.id}" class="delete-period-button text-red-400 hover:text-red-600 transition-colors p-1">
                    <i class="fas fa-times-circle text-lg"></i>
                </button>
            `;

            item.querySelector('.delete-period-button').addEventListener('click', () => deletePeriod(period.id, `Supprimer cette période d'indisponibilité ?`));
            return item;
        }

        function createManualStatusItem(carName, status) {
            const item = document.createElement('div');
            item.className = 'flex justify-between items-center p-3 rounded-lg bg-gray-50 border';
            
            const isUnavailable = status === 'unavailable';
            const statusText = isUnavailable ? 'Indisponible' : 'Disponible';
            const statusClass = isUnavailable ? 'text-red-600 font-semibold' : 'text-green-600 font-semibold';
            const buttonText = isUnavailable ? 'Rendre Disponible' : 'Marquer Indisponible';
            const buttonClass = isUnavailable ? 'btn-success' : 'btn-warning';

            item.innerHTML = `
                <span class="font-medium text-text-dark">${carName}</span>
                <div class="${statusClass} text-sm">${statusText}</div>
                <button data-car="${carName}" data-status="${isUnavailable ? 'available' : 'unavailable'}" class="toggle-status-button btn ${buttonClass} btn-sm py-1">
                    ${buttonText}
                </button>
            `;

            item.querySelector('.toggle-status-button').addEventListener('click', (e) => {
                const car = e.target.dataset.car;
                const newStatus = e.target.dataset.status;
                const confirmMsg = newStatus === 'unavailable' 
                    ? `Marquer ${car} comme INDISPONIBLE manuellement ? (bloquera toutes les réservations)`
                    : `Marquer ${car} comme DISPONIBLE ?`;
                toggleManualStatus(car, newStatus, confirmMsg);
            });
            return item;
        }
        
        // --- NOUVELLE FONCTION: Créer un item pour l'historique client ---
        function createClientHistoryItem(clientData) {
            const item = document.createElement('div');
            item.className = 'flex justify-between items-center bg-gray-50 p-3 rounded-lg text-sm';
            
            // Couleur basée sur le nombre de réservations
            let countColor = 'text-primary'; // Bleu (défaut)
            if (clientData.count >= 5) {
                countColor = 'text-accent'; // Jaune/Or
            } else if (clientData.count >= 2) {
                countColor = 'text-green-600'; // Vert
            }

            item.innerHTML = `
                <div>
                    <strong class="text-text-dark">${clientData.nom}</strong>
                    <p class="text-xs text-gray-500">${clientData.telephone}</p>
                </div>
                <span class="font-bold text-lg ${countColor}">${clientData.count}</span>
            `;
            return item;
        }


        // --- FONCTIONS LOGIQUES (Firestore) ---

        // ** CORRECTION: LOGIQUE DE FILTRAGE DÉPLACÉE EN JAVASCRIPT **
        function displayBookings(view) {
            const listDiv = domElements.bookingsList;
            const loadingMsg = domElements.loadingBookings;
            const countNew = domElements.countNew;
            const countConfirmed = domElements.countConfirmed;
            
            if (!listDiv || !loadingMsg || !countNew || !countConfirmed) {
                // Cette erreur ne devrait plus se produire grâce à initDomElements
                console.error("Éléments UI manquants pour displayBookings");
                return;
            }

            listDiv.innerHTML = ''; // Nettoyer la liste
            currentView = view;

            // Mettre à jour les styles des onglets
            domElements.tabNew.classList.toggle('active', view === 'new');
            domElements.tabConfirmed.classList.toggle('active', view === 'confirmed');

            const isConfirmedView = (view === 'confirmed');
            
            // Filtrer le cache JavaScript
            const bookingsToDisplay = allBookingsCache.filter(booking => {
                // (booking.confirmed === true) pour 'confirmed'
                // (booking.confirmed === false) pour 'new'
                return booking.confirmed === isConfirmedView;
            });

            // Mettre à jour les compteurs
            countNew.textContent = allBookingsCache.filter(b => !b.confirmed).length;
            countConfirmed.textContent = allBookingsCache.filter(b => b.confirmed).length;

            if (bookingsToDisplay.length === 0) {
                loadingMsg.textContent = `Aucune ${view === 'new' ? 'nouvelle demande' : 'réservation confirmée'} pour le moment.`;
                loadingMsg.style.display = 'block';
            } else {
                loadingMsg.style.display = 'none';
                bookingsToDisplay.forEach(booking => {
                    listDiv.appendChild(createBookingCard(booking));
                });
            }
        }
        
        // --- NOUVELLE FONCTION: Mettre à jour l'historique des clients ---
        function updateClientHistory(allBookings) {
            const listDiv = domElements.clientHistoryList;
            const loadingMsg = domElements.loadingClientHistory;
            if (!listDiv || !loadingMsg) {
                 console.error("Éléments UI manquants pour updateClientHistory");
                 return;
            }

            // 1. Filtrer pour les réservations CONFIRMÉES
            const confirmedBookings = allBookings.filter(b => b.confirmed === true);
            const clientCounts = new Map();

            // 2. Compter par client (téléphone + nom comme clé)
            for (const booking of confirmedBookings) {
                if (!booking.telephone || !booking.nomPrenom) continue; // Ignorer si données incomplètes
                
                // Clé unique basée sur le téléphone normalisé ET le nom
                const phone = booking.telephone.replace(/\s+/g, '');
                const name = booking.nomPrenom.toLowerCase().trim();
                const key = `${phone}::${name}`;
                
                if (!clientCounts.has(key)) {
                    // Utiliser le nom avec la bonne casse pour l'affichage
                    clientCounts.set(key, { nom: booking.nomPrenom, telephone: booking.telephone, count: 0 });
                }
                clientCounts.get(key).count++;
            }

            listDiv.innerHTML = ''; // Vider la liste
            
            // 3. Afficher
            if (clientCounts.size === 0) {
                loadingMsg.textContent = 'Aucun client confirmé.';
                loadingMsg.style.display = 'block';
            } else {
                loadingMsg.style.display = 'none';
                // Convertir en tableau, trier par count (descendant)
                const sortedClients = Array.from(clientCounts.values()).sort((a, b) => b.count - a.count);
                
                sortedClients.forEach(clientData => {
                    listDiv.appendChild(createClientHistoryItem(clientData));
                });
            }
        }

        // --- NOUVEAU: Fonction pour envoyer la notification ---
        function sendNewBookingNotification(booking) {
             if (Notification.permission !== 'granted') {
                 console.warn('Permission de notification non accordée, impossible d_envoyer.');
                 return;
             }
             if (!navigator.serviceWorker.controller) {
                 console.warn('Service Worker non actif, notification différée.');
                 // Tenter une notification locale (moins fiable)
                 new Notification("Nouvelle Réservation !", {
                     body: `${booking.nomPrenom} - ${booking.voiture}`,
                     icon: '/icons/icon-192x192.png',
                     badge: '/icons/icon-192x192.png'
                 });
                 return;
             }
             
             const title = 'Nouvelle Réservation !';
             const options = {
                body: `${booking.nomPrenom} demande la ${booking.voiture}.`,
                icon: '/icons/icon-192x192.png',
                badge: '/icons/icon-192x192.png',
                vibrate: [200, 100, 200],
                tag: 'new-booking' // Permet de remplacer les notifs non lues
             };

             // Envoyer au Service Worker pour affichage
             navigator.serviceWorker.controller.postMessage({
                 type: 'show-notification',
                 title: title,
                 options: options
             });
        }


        // ** CORRECTION: REQUÊTE FIRESTORE SIMPLIFIÉE (Évite l'erreur d'index) **
        function loadBookings() {
            const loadingMsg = domElements.loadingBookings;

            const q = query(
                bookingsCollectionRef, 
                orderBy("timestamp", "desc")
            );

            onSnapshot(q, (snapshot) => {
                loadingMsg.textContent = 'Chargement des réservations...';
                
                // NOUVEAU: Logique de détection de changement pour les notifications
                snapshot.docChanges().forEach((change) => {
                    const data = change.doc.data();
                    const booking = { ...data, id: change.doc.id };

                    if (change.type === "added") {
                        if (data.deleted !== true) {
                            console.log("Nouvelle réservation détectée:", booking.id);
                            allBookingsCache.unshift(booking); // Ajouter au début
                            
                            // NOUVEAU: Déclencher la notif SEULEMENT si ce n'est pas le chargement initial
                            if (!isFirstLoad && data.confirmed === false) {
                                sendNewBookingNotification(booking);
                            }
                        }
                    } 
                    else if (change.type === "modified") {
                        console.log("Réservation modifiée:", booking.id);
                        const index = allBookingsCache.findIndex(b => b.id === booking.id);
                        if (index > -1) {
                            allBookingsCache[index] = booking; // Mettre à jour
                            // Si elle est marquée comme "deleted: true", on la retire du cache
                            if (data.deleted === true) {
                                 allBookingsCache.splice(index, 1);
                            }
                        }
                    } 
                    else if (change.type === "removed") {
                        console.log("Réservation supprimée (hard delete):", booking.id);
                        allBookingsCache = allBookingsCache.filter(b => b.id !== booking.id);
                    }
                });

                // Trier le cache au cas où (bien que 'unshift' devrait maintenir l'ordre)
                allBookingsCache.sort((a, b) => (b.timestamp?.seconds || 0) - (a.timestamp?.seconds || 0));

                // Afficher la vue actuellement sélectionnée avec les données mises à jour
                displayBookings(currentView); 
                
                // NOUVEAU: Mettre à jour l'historique client
                updateClientHistory(allBookingsCache);

                // Marquer la fin du premier chargement
                isFirstLoad = false;

            }, (error) => {
                console.error("Erreur lors de la récupération des réservations (onSnapshot): ", error);
                loadingMsg.textContent = "Erreur: Impossible de charger les réservations. Vérifiez la console (F12).";
                loadingMsg.style.color = 'red';
                if (error.code === 'failed-precondition' && error.message.includes('index')) {
                     loadingMsg.innerHTML = `<strong>Erreur:</strong> Index Firestore manquant. <br>Veuillez suivre le lien dans la console (F12) pour le créer (index sur 'timestamp' desc).`;
                }
            });
        }


        function listenForPeriods() {
            const listDiv = domElements.periodsList;
            const loadingMsg = domElements.loadingPeriods;

            const q = query(
                unavailabilityPeriodsCollectionRef, 
                orderBy("startDate", "desc")
            );

            onSnapshot(q, (snapshot) => {
                listDiv.innerHTML = ''; // Clear list
                if (snapshot.empty) {
                    loadingMsg.textContent = 'Aucune période programmée.';
                    loadingMsg.style.display = 'block';
                } else {
                    loadingMsg.style.display = 'none';
                    snapshot.forEach((doc) => {
                        listDiv.appendChild(createPeriodListItem({ ...doc.data(), id: doc.id }));
                    });
                }
            }, (error) => {
                console.error("Erreur écoute périodes:", error);
                loadingMsg.textContent = 'Erreur chargement périodes.';
                loadingMsg.style.color = 'red';
                if (error.code === 'failed-precondition' && error.message.includes('index')) {
                     loadingMsg.innerHTML = `<strong>Erreur:</strong> Index Firestore manquant (périodes). <br>Suivez le lien dans la console (F12) pour le créer.`;
                }
            });
        }

        function listenForManualStatusChanges() {
            const listDiv = domElements.manualStatusList;
            const statusMap = new Map();

            // Initialiser toutes les voitures comme "disponibles"
            carOptions.forEach(carName => statusMap.set(carName, 'available'));

            // Écouter les changements dans la collection 'car_manual_status'
            onSnapshot(carManualStatusCollectionRef, (snapshot) => {
                // Réinitialiser les statuts (au cas où un doc est supprimé)
                 carOptions.forEach(carName => statusMap.set(carName, 'available'));
                // Mettre à jour le statut pour les voitures présentes dans la collection
                snapshot.forEach((doc) => {
                    statusMap.set(doc.id, doc.data().status || 'available');
                });

                // Rafraîchir l'affichage
                listDiv.innerHTML = '';
                statusMap.forEach((status, carName) => {
                    listDiv.appendChild(createManualStatusItem(carName, status));
                });

            }, (error) => {
                console.error("Erreur écoute statuts manuels:", error);
                listDiv.innerHTML = '<p class="text-red-500">Erreur chargement statuts.</p>';
            });
        }

        // --- FONCTIONS MODALE ---

        function openConfirmationModal(bookingId) {
            currentBookingId = bookingId;
            currentBookingData = allBookingsCache.find(b => b.id === bookingId);
            if (!currentBookingData) {
                console.error("Impossible de trouver les données pour la réservation:", bookingId);
                showAdminMessage("Erreur: Impossible de charger les détails de cette réservation.", "error");
                return;
            }

            const modal = domElements.confirmationModal;
            const detailsDiv = domElements.modalBookingDetails;
            const startDateInput = domElements.modalStartDate;
            const startTimeInput = domElements.modalStartTime;
            const endDateInput = domElements.modalEndDate;
            const endTimeInput = domElements.modalEndTime;
            const confirmButton = domElements.confirmModalButton;

            // Remplir les détails
            detailsDiv.innerHTML = `
                <p><strong>Client:</strong> ${currentBookingData.nomPrenom}</p>
                <p><strong>Voiture:</strong> ${currentBookingData.voiture}</p>
            `;
            
            // Remplir les dates/heures actuelles
            // Préférer les timestamps s'ils existent (plus fiables)
            let pickupDate, returnDate;

            if (currentBookingData.pickupTimestamp) {
                pickupDate = getDateTimeObjectFromTimestamp(currentBookingData.pickupTimestamp);
            } else {
                // Fallback pour les anciennes réservations sans timestamp (string)
                pickupDate = { date: currentBookingData.datePriseEnCharge || '', time: currentBookingData.heurePriseEnCharge || '12:00' };
            }

            if (currentBookingData.returnTimestamp) {
                returnDate = getDateTimeObjectFromTimestamp(currentBookingData.returnTimestamp);
            } else {
                // Fallback pour les anciennes réservations sans timestamp (string)
                returnDate = { date: currentBookingData.dateRetour || '', time: currentBookingData.heureRetour || '12:00' };
            }
            
            startDateInput.value = pickupDate.date;
            startTimeInput.value = pickupDate.time;
            endDateInput.value = returnDate.date;
            endTimeInput.value = returnDate.time;

            // Activer le bouton de confirmation
            confirmButton.disabled = false;

            modal.classList.remove('hidden');
            setTimeout(() => modal.classList.remove('opacity-0'), 10);
            setTimeout(() => modal.querySelector('.modal-content').classList.remove('opacity-0', 'scale-95', '-translate-y-10'), 50);
        }

        function closeConfirmationModal() {
            const modal = domElements.confirmationModal;
            const modalError = domElements.modalError;
            const confirmButton = domElements.confirmModalButton;
            
            modal.querySelector('.modal-content').classList.add('opacity-0', 'scale-95', '-translate-y-10');
            setTimeout(() => {
                modal.classList.add('opacity-0');
                setTimeout(() => {
                    modal.classList.add('hidden');
                    modalError.classList.add('hidden');
                    currentBookingId = null;
                    currentBookingData = null;
                    confirmButton.disabled = true; // Désactiver pour la prochaine ouverture
                }, 300);
            }, 300);
        }

        // --- ACTIONS ADMIN (Confirmation, Suppression, etc.) ---

        async function handleFinalConfirmation() {
            if (!currentBookingId || !currentBookingData || isConfirmationBusy) return;

            isConfirmationBusy = true; // Activer le verrou
            const modalError = domElements.modalError;
            const confirmButton = domElements.confirmModalButton;
            modalError.classList.add('hidden');
            confirmButton.disabled = true;
            confirmButton.innerHTML = '<i class="fas fa-spinner animate-spin mr-2"></i> Confirmation...';


            // Récupérer les dates (potentiellement modifiées)
            const newStartDate = domElements.modalStartDate.value;
            const newStartTime = domElements.modalStartTime.value;
            const newEndDate = domElements.modalEndDate.value;
            const newEndTime = domElements.modalEndTime.value;

            // Validation (ajoutée)
            if (!newStartDate || !newStartTime || !newEndDate || !newEndTime) {
                modalError.textContent = "Erreur : Tous les champs de date et d'heure sont requis.";
                modalError.classList.remove('hidden');
                confirmButton.disabled = false;
                confirmButton.innerHTML = '<i class="fas fa-check mr-2"></i> Confirmer la Réservation';
                isConfirmationBusy = false; // Relâcher le verrou
                return;
            }

            // Combiner date et heure
            const newPickupDateTime = getDateTimeObjectFromISO(newStartDate, newStartTime);
            const newReturnDateTime = getDateTimeObjectFromISO(newEndDate, newEndTime);

            // Validation
            if (!newPickupDateTime || !newReturnDateTime || newPickupDateTime >= newReturnDateTime) {
                modalError.textContent = "Erreur : La date/heure de fin doit être après la date/heure de début.";
                modalError.classList.remove('hidden');
                confirmButton.disabled = false;
                confirmButton.innerHTML = '<i class="fas fa-check mr-2"></i> Confirmer la Réservation';
                isConfirmationBusy = false; // Relâcher le verrou
                return;
            }
            
            const batch = writeBatch(db);

            try {
                // 1. Mettre à jour la réservation
                const bookingRef = doc(db, "palace_cars_bookings", currentBookingId);
                batch.update(bookingRef, {
                    confirmed: true,
                    datePriseEnCharge: newStartDate,
                    heurePriseEnCharge: newStartTime,
                    dateRetour: newEndDate,
                    heureRetour: newEndTime,
                    // Mettre à jour les timestamps (très important pour la vérification)
                    pickupTimestamp: Timestamp.fromDate(newPickupDateTime), 
                    returnTimestamp: Timestamp.fromDate(newReturnDateTime)
                });

                // 2. Créer la période d'indisponibilité
                const unavailabilityData = {
                    car: currentBookingData.voiture,
                    startDate: Timestamp.fromDate(newPickupDateTime),
                    endDate: Timestamp.fromDate(newReturnDateTime),
                    type: 'booking', // Marqué comme généré par une réservation
                    bookingId: currentBookingId // Lien vers la réservation
                };
                // Nous créons un nouveau doc dans la collection d'indisponibilité
                const newPeriodRef = doc(unavailabilityPeriodsCollectionRef); // CORRECTION: doc(collection(...)) -> doc(...)
                batch.set(newPeriodRef, unavailabilityData);

                // 3. Exécuter le batch
                await batch.commit();

                showAdminMessage(`Réservation ${currentBookingId.substring(0, 5)}... confirmée et voiture bloquée.`, 'success');
                closeConfirmationModal();
                
                // NOUVEAU: Mettre à jour manuellement le cache et rafraîchir les vues
                // (onSnapshot prendra quelques secondes, ceci est plus rapide)
                const index = allBookingsCache.findIndex(b => b.id === currentBookingId);
                if (index > -1) {
                    allBookingsCache[index].confirmed = true;
                    // Mettre à jour les données de date/heure aussi
                    allBookingsCache[index].datePriseEnCharge = newStartDate;
                    allBookingsCache[index].heurePriseEnCharge = newStartTime;
                    allBookingsCache[index].dateRetour = newEndDate;
                    allBookingsCache[index].heureRetour = newEndTime;
                    allBookingsCache[index].pickupTimestamp = Timestamp.fromDate(newPickupDateTime);
                    allBookingsCache[index].returnTimestamp = Timestamp.fromDate(newReturnDateTime);
                }
                displayBookings(currentView);
                updateClientHistory(allBookingsCache); // Rafraîchir l'historique client

            } catch (error) {
                console.error("Erreur lors de la confirmation finale:", error);
                modalError.textContent = "Erreur Firestore. Vérifiez la console.";
                modalError.classList.remove('hidden');
            } finally {
                confirmButton.disabled = false;
                confirmButton.innerHTML = '<i class="fas fa-check mr-2"></i> Confirmer la Réservation';
                isConfirmationBusy = false; // Relâcher le verrou
            }
        }


        async function handleDeleteBooking(bookingId) {
            // Utiliser la modale de confirmation custom
            const confirmed = await customConfirm(
                `Êtes-vous sûr de vouloir supprimer la réservation ID: ${bookingId.substring(0, 5)}... ?<br>(Cela libérera aussi le créneau si elle était confirmée.)`,
                "Supprimer Réservation",
                "btn-danger"
            );
            if (!confirmed) return;

            try {
                const batch = writeBatch(db);

                // 1. Marquer la réservation comme supprimée (soft delete)
                const bookingRef = doc(db, "palace_cars_bookings", bookingId);
                batch.update(bookingRef, { deleted: true });

                // 2. Trouver et supprimer la période d'indisponibilité associée
                // (Nécessite l'index sur 'bookingId' dans 'car_unavailability_periods')
                const q = query(unavailabilityPeriodsCollectionRef, where("bookingId", "==", bookingId));
                const periodSnapshot = await getDocs(q);
                
                if (!periodSnapshot.empty) {
                    periodSnapshot.forEach(docSnap => {
                        batch.delete(docSnap.ref);
                    });
                    console.log("Période d'indisponibilité associée supprimée.");
                }

                // 3. Exécuter le batch
                await batch.commit();

                showAdminMessage(`Réservation ${bookingId.substring(0, 5)}... supprimée/archivée.`, 'success');
                
                // NOUVEAU: Mettre à jour manuellement le cache et rafraîchir les vues
                allBookingsCache = allBookingsCache.filter(b => b.id !== bookingId);
                displayBookings(currentView);
                updateClientHistory(allBookingsCache); // Rafraîchir l'historique client

            } catch (error) {
                console.error("Erreur lors de la suppression:", error);
                showAdminMessage("Erreur lors de la suppression. Vérifiez la console.", 'error');
                if (error.code === 'failed-precondition' && error.message.includes('index')) {
                     showAdminMessage("Erreur: Index Firestore manquant pour la suppression. Suivez le lien dans la console (F12) pour le créer (index sur 'bookingId').", 'error', 10000);
                }
            }
        }

        async function toggleManualStatus(carName, newStatus, confirmMsg) {
            const confirmed = await customConfirm(
                confirmMsg,
                "Changer Statut Manuel",
                newStatus === 'unavailable' ? 'btn-warning' : 'btn-success'
            );
            if (!confirmed) return;

            const carStatusRef = doc(db, "car_manual_status", carName);

            try {
                if (newStatus === 'unavailable') {
                    // Marquer comme indisponible
                    await setDoc(carStatusRef, { status: 'unavailable' });
                    showAdminMessage(`${carName} est maintenant marqué INDISPONIBLE.`, 'warning');
                } else {
                    // Marquer comme disponible (en supprimant le document)
                    await deleteDoc(carStatusRef);
                    showAdminMessage(`${carName} est maintenant DISPONIBLE.`, 'success');
                }
                // L'affichage se met à jour via onSnapshot
            } catch (error) {
                 console.error("Erreur mise à jour statut manuel:", error);
                 showAdminMessage("Erreur Firestore. Vérifiez la console.", 'error');
            }
        }

        async function deletePeriod(periodId, confirmMsg) {
            const confirmed = await customConfirm(
                confirmMsg,
                "Supprimer Période",
                "btn-danger"
            );
            if (!confirmed) return;
            
            try {
                const periodRef = doc(db, "car_unavailability_periods", periodId);
                await deleteDoc(periodRef);
                showAdminMessage(`Période ${periodId.substring(0,5)}... supprimée.`, 'success');
                // L'affichage se met à jour via onSnapshot
            } catch (error) {
                 console.error("Erreur suppression période:", error);
                 showAdminMessage("Erreur Firestore. Vérifiez la console.", 'error');
            }
        }


        async function addUnavailability(event) {
            event.preventDefault();
            const form = event.target;
            const car = form.car.value;
            const startDate = form.startDate.value;
            const startTime = form.startTime.value;
            const endDate = form.endDate.value;
            const endTime = form.endTime.value;
            const button = form.querySelector('button');
            
            if (!car || !startDate || !startTime || !endDate || !endTime) {
                showAdminMessage("Veuillez remplir tous les champs de période.", 'warning');
                return;
            }

            const pickupDateTime = getDateTimeObjectFromISO(startDate, startTime);
            const returnDateTime = getDateTimeObjectFromISO(endDate, endTime);

            if (!pickupDateTime || !returnDateTime || pickupDateTime >= returnDateTime) {
                showAdminMessage("Date/heure de fin doit être après la date/heure de début.", 'warning');
                return;
            }
            
            button.disabled = true;

            try {
                 const unavailabilityData = {
                      car: car,
                      startDate: Timestamp.fromDate(pickupDateTime),
                      endDate: Timestamp.fromDate(returnDateTime),
                      type: 'manual', // Marqué comme manuel
                      bookingId: null // Pas de lien de réservation
                 };
                
                 await addDoc(unavailabilityPeriodsCollectionRef, unavailabilityData);
                 showAdminMessage(`Période d'indisponibilité ajoutée pour ${car}.`, 'success');
                 form.reset();

            } catch (error) {
                 console.error("Erreur ajout période:", error);
                 showAdminMessage("Erreur Firestore. Vérifiez la console.", 'error');
            } finally {
                 button.disabled = false;
            }
        }

        function toggleView(view) {
            displayBookings(view); // Appelle la nouvelle fonction de filtrage JS
        }
        
        // --- NOUVELLE FONCTION: Initialisation des éléments DOM ---
        function initDomElements() {
             const ids = [
                 'login-overlay', 'login-button', 'password-input', 'login-error', 'main-content',
                 'admin-message-box', 'tab-new', 'tab-confirmed', 'count-new', 'count-confirmed',
                 'bookings-list', 'loading-bookings', 'unavailability-form', 'unav-car',
                 'manual-status-list', 'periods-list', 'loading-periods',
                 'confirmation-modal', 'close-modal-button', 'modal-booking-details',
                 'modal-start-date', 'modal-start-time', 'modal-end-date', 'modal-end-time',
                 'modal-error', 'cancel-modal-button', 'confirm-modal-button',
                 'enable-notifications', 'notifications-status',
                 // Nouveaux éléments
                 'client-history-list', 'loading-client-history',
                 'custom-confirm-modal', 'custom-confirm-title', 'custom-confirm-message',
                 'custom-confirm-cancel', 'custom-confirm-ok'
             ];
             let allFound = true;
             ids.forEach(id => {
                 const el = document.getElementById(id);
                 if (!el) {
                     console.error(`Élément DOM manquant: #${id}`);
                     allFound = false;
                 }
                 // Convertir 'client-history-list' en 'clientHistoryList'
                 const camelCaseId = id.replace(/-(\w)/g, (match, p1) => p1.toUpperCase());
                 domElements[camelCaseId] = el;
             });
             return allFound;
        }


        // --- INITIALISATION (Login, PWA, etc.) ---

        document.addEventListener('DOMContentLoaded', () => {
            
            // 1. Initialiser tous les éléments DOM
            if (!initDomElements()) {
                // Remplacer l'alert() natif
                document.body.innerHTML = `<div style="padding: 2rem; background-color: #fef2f2; border: 1px solid #fecaca; color: #b91c1c; font-family: sans-serif; text-align: center;">Erreur critique: Certains éléments de la page sont manquants. L'application ne peut pas démarrer.</div>`;
                return;
            }
            
            // 1.5 Initialiser les écouteurs de la modale de confirmation custom
            setupCustomConfirmListeners();

            // 2. Remplir les listes de voitures
            populateCarSelects();

            // 3. Gestion Login
            function handleLogin() {
                if (domElements.passwordInput.value === "12234") {
                    domElements.loginOverlay.classList.add('opacity-0', 'pointer-events-none');
                    domElements.mainContent.classList.remove('hidden');
                    setTimeout(() => domElements.mainContent.classList.remove('opacity-0'), 50); // Fade in
                    setTimeout(() => domElements.loginOverlay.style.display = 'none', 500); // Hide completely

                    // Démarrer les écouteurs Firestore SEULEMENT APRES le login
                    if (dbReady) {
                        try {
                            loadBookings();
                            listenForPeriods();
                            listenForManualStatusChanges();
                        } catch (e) {
                            console.error("Erreur au démarrage des écouteurs Firestore:", e);
                            showAdminMessage("Erreur de connexion à Firestore. Vérifiez la console.", "error");
                        }
                    } else {
                        console.error("DB non prête au moment du login.");
                        showAdminMessage("La connexion à la base de données a échoué.", "error");
                    }

                } else {
                    domElements.loginError.classList.remove('hidden');
                    domElements.passwordInput.classList.add('border-red-500', 'ring-red-500');
                    domElements.passwordInput.focus();
                }
            }
            
            domElements.loginButton.addEventListener('click', handleLogin);
            domElements.passwordInput.addEventListener('keyup', (e) => {
                domElements.loginError.classList.add('hidden');
                domElements.passwordInput.classList.remove('border-red-500', 'ring-red-500');
                if (e.key === 'Enter') handleLogin();
            });

            // 4. Écouteurs Modale
            domElements.closeModalButton.addEventListener('click', closeConfirmationModal);
            domElements.cancelModalButton.addEventListener('click', closeConfirmationModal);
            domElements.confirmModalButton.addEventListener('click', handleFinalConfirmation);

            // 5. Écouteurs Formulaire Indisponibilité
            domElements.unavailabilityForm.addEventListener('submit', addUnavailability);

            // 6. Écouteurs Onglets
            domElements.tabNew.addEventListener('click', () => toggleView('new'));
            domElements.tabConfirmed.addEventListener('click', () => toggleView('confirmed'));

            // 7. Initialisation PWA (Service Worker & Notifications)
            const notifButton = domElements.enableNotifications;
            const notifStatus = domElements.notificationsStatus;
            
            // 7.1 Enregistrement Service Worker
            if ('serviceWorker' in navigator) {
                 // ** CORRECTION: Vérifier le protocole **
                 if (window.location.protocol === 'http:' || window.location.protocol === 'https:') {
                     window.addEventListener('load', () => {
                         navigator.serviceWorker.register('/sw.js')
                             .then(registration => {
                                 console.log('Service Worker enregistré avec succès:', registration.scope);
                             })
                             .catch(error => {
                                 console.error('Échec de l\'enregistrement du Service Worker:', error);
                             });
                     });
                 } else {
                     console.warn("Le Service Worker ne peut pas être enregistré sur ce protocole:", window.location.protocol);
                 }
            }

            // 7.2 Demande de Permission Notification
            function requestNotificationPermission() {
                if ('Notification' in window) {
                    Notification.requestPermission().then(permission => {
                        if (permission === 'granted') {
                            notifStatus.classList.remove('hidden');
                            notifButton.classList.add('hidden');
                            console.log('Permission de notification accordée.');
                            // Envoyer une notification de test
                            if (navigator.serviceWorker.controller) {
                                navigator.serviceWorker.controller.postMessage({
                                    type: 'show-notification',
                                    title: 'Palace Cars Admin',
                                    options: {
                                        body: 'Les notifications sont activées !',
                                        icon: '/icons/icon-192x192.png',
                                        badge: '/icons/icon-192x192.png',
                                        vibrate: [200, 100, 200]
                                    }
                                });
                            }
                        } else {
                            console.warn('Permission de notification refusée.');
                            showAdminMessage('Les notifications ont été bloquées.', 'warning');
                        }
                    });
                } else {
                    console.error('Ce navigateur ne supporte pas les notifications.');
                    showAdminMessage('Ce navigateur ne supporte pas les notifications.', 'error');
                }
            }

            notifButton.addEventListener('click', requestNotificationPermission);
            // Vérifier si la permission est déjà accordée
            if (window.Notification && Notification.permission === 'granted') {
                notifStatus.classList.remove('hidden');
                notifButton.classList.add('hidden');
            }


            // 8. --- Connexion Firebase ---
            (async () => {
                try {
                    const app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    bookingsCollectionRef = collection(db, "palace_cars_bookings");
                    unavailabilityPeriodsCollectionRef = collection(db, "car_unavailability_periods");
                    carManualStatusCollectionRef = collection(db, "car_manual_status");
                    dbReady = true;
                    console.log("Firebase initialisé avec succès (DOMContentLoaded).");
                } catch (error) {
                    console.error("Erreur critique d'initialisation Firebase:", error);
                    domElements.loginButton.disabled = true;
                    domElements.loginButton.textContent = "Erreur DB";
                    domElements.loginError.textContent = "Impossible de connecter à Firebase. Vérifiez la console.";
                    domElements.loginError.classList.remove('hidden');
                }
            })();

        }); // Fin DOMContentLoaded
    </script>
</body>
</html>
